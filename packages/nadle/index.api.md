## API Report File for "nadle"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Writable } from 'node:stream';

// @public (undocumented)
export type Awaitable<T> = T | PromiseLike<T>;

// @public (undocumented)
export type Callback<T = unknown, P = {
    context: Context;
}> = (params: P) => T;

// @public (undocumented)
export interface ConfigBuilder {
    // (undocumented)
    config(builder: Callback<TaskConfiguration> | TaskConfiguration): void;
}

// @public (undocumented)
export function configure(options: Partial<NadleConfigFileOptions>): void;

// @public (undocumented)
export interface Context {
    // (undocumented)
    readonly nadle: Nadle;
}

// @public (undocumented)
export class DefaultReporter implements Reporter {
    constructor(nadle: Nadle);
    // (undocumented)
    readonly nadle: Nadle;
    // (undocumented)
    onExecutionFailed(error: any): Promise<void>;
    // (undocumented)
    onExecutionFinish(): Promise<void>;
    // (undocumented)
    onExecutionStart(): Promise<void>;
    // (undocumented)
    onInit(): void;
    // (undocumented)
    onTaskFailed(task: RegisteredTask): Promise<void>;
    // (undocumented)
    onTaskFinish(task: RegisteredTask): Promise<void>;
    // (undocumented)
    onTaskQueued(task: RegisteredTask): Promise<void>;
    // (undocumented)
    onTaskStart(task: RegisteredTask): Promise<void>;
}

// @public (undocumented)
export const ExecTask: Task<{
    command: string;
    args: string[] | string;
}>;

// @public (undocumented)
export function formatSuggestions(names: string[]): string;

// @public (undocumented)
export class Logger {
    constructor(options: LoggerOptions);
    // (undocumented)
    clearFullScreen(message?: string): void;
    // (undocumented)
    clearScreen(message: string, force?: boolean): void;
    // (undocumented)
    debug(message: any, ...args: unknown[]): void;
    // (undocumented)
    error(message: any, ...args: unknown[]): void;
    // (undocumented)
    errorStream: NodeJS.WriteStream | Writable;
    // (undocumented)
    getColumns(): number;
    // (undocumented)
    info(message: any, ...args: unknown[]): void;
    // (undocumented)
    log(message: any, ...args: unknown[]): void;
    // (undocumented)
    options: Required<LoggerOptions>;
    // (undocumented)
    outputStream: NodeJS.WriteStream | Writable;
    // (undocumented)
    warn(message: any, ...args: unknown[]): void;
}

// @public (undocumented)
export interface LoggerOptions {
    // @internal (undocumented)
    readonly isWorkerThread?: boolean;
    // (undocumented)
    readonly logLevel?: SupportLogLevel;
}

// @public (undocumented)
export class Nadle {
    constructor(options: NadleCLIOptions);
    // (undocumented)
    computeTaskGroups(): [string, (RegisteredTask & {
        description?: string;
    })[]][];
    // (undocumented)
    execute(tasks: string[]): Promise<void>;
    // (undocumented)
    listTasks(): void;
    // (undocumented)
    readonly logger: Logger;
    // (undocumented)
    onTaskFailed(task: RegisteredTask): Promise<void>;
    // (undocumented)
    onTaskFinish(task: RegisteredTask): Promise<void>;
    // (undocumented)
    onTaskQueued(task: RegisteredTask): Promise<void>;
    // (undocumented)
    onTaskStart(task: RegisteredTask): Promise<void>;
    // (undocumented)
    get options(): NadleResolvedOptions;
    // (undocumented)
    printNoTasksFound(): void;
    // (undocumented)
    registerTask(): Promise<void>;
    // (undocumented)
    readonly registry: TaskRegistry;
    // (undocumented)
    readonly reporter: Reporter;
    // (undocumented)
    showConfig(): void;
    // (undocumented)
    readonly version: string;
}

// @public (undocumented)
export interface NadleCLIOptions extends NadleUserBaseOptions {
    // (undocumented)
    readonly configPath?: string;
    // (undocumented)
    readonly dryRun: boolean;
    // (undocumented)
    readonly list: boolean;
    // (undocumented)
    readonly showConfig: boolean;
    // (undocumented)
    readonly stacktrace: boolean;
}

// @public (undocumented)
export interface NadleConfigFileOptions extends NadleUserBaseOptions {
}

// @public (undocumented)
export interface NadleResolvedOptions extends Required<Omit<NadleCLIOptions, "maxWorkers" | "minWorkers">> {
    // (undocumented)
    readonly maxWorkers: number;
    // (undocumented)
    readonly minWorkers: number;
}

// @public (undocumented)
export interface NadleUserBaseOptions {
    // @internal (undocumented)
    readonly isWorkerThread?: boolean;
    // (undocumented)
    readonly logLevel?: SupportLogLevel;
    // (undocumented)
    readonly maxWorkers?: number | string;
    // (undocumented)
    readonly minWorkers?: number | string;
    // (undocumented)
    readonly sequence?: boolean;
    // (undocumented)
    readonly showSummary?: boolean;
}

// @public (undocumented)
export const PnpmTask: Task<{
    args: string[];
}>;

// @public (undocumented)
export interface RegisteredTask extends Task {
    // (undocumented)
    configResolver: Callback<TaskConfiguration>;
    // (undocumented)
    name: string;
    // (undocumented)
    optionsResolver: Resolver | undefined;
    // (undocumented)
    result: {
        duration: number | null;
        startTime: number | null;
    };
    // (undocumented)
    status: TaskStatus;
}

// @public (undocumented)
export interface Reporter {
    // (undocumented)
    onExecutionFailed?: (error: any) => Awaitable<void>;
    // (undocumented)
    onExecutionFinish?: () => Awaitable<void>;
    // (undocumented)
    onExecutionStart?: () => Awaitable<void>;
    // (undocumented)
    onInit?: () => void;
    // (undocumented)
    onTaskFailed?: (task: RegisteredTask) => Awaitable<void>;
    // (undocumented)
    onTaskFinish?: (task: RegisteredTask) => Awaitable<void>;
    // (undocumented)
    onTaskQueued?: (task: RegisteredTask) => Awaitable<void>;
    // (undocumented)
    onTaskStart?: (task: RegisteredTask) => Awaitable<void>;
}

// @public (undocumented)
export type Resolver<T = unknown> = T | Callback<T>;

// @public (undocumented)
export function resolveTask(input: string, allTasks: string[]): {
    result: string;
} | {
    result: undefined;
    suggestions: string[];
};

// @public (undocumented)
export type SupportLogLevel = (typeof SupportLogLevels)[number];

// @public (undocumented)
export const SupportLogLevels: ["error", "log", "info", "debug"];

// @public (undocumented)
export interface Task<Options = unknown> {
    // (undocumented)
    run: Callback<Awaitable<void>, {
        options: Options;
        context: Context & {
            workingDir: string;
        };
    }>;
}

// @public (undocumented)
export interface TaskConfiguration {
    dependsOn?: string[];
    description?: string;
    env?: TaskEnv;
    group?: string;
    workingDir?: string;
}

// @public (undocumented)
export type TaskEnv = Record<string, string | number | boolean>;

// @public (undocumented)
export type TaskFn = Callback<Awaitable<void>, {
    context: Context & {
        workingDir: string;
    };
}>;

// @public (undocumented)
export class TaskRegistry {
    // (undocumented)
    findByName(taskName: string): RegisteredTask | undefined;
    // (undocumented)
    getAll(): RegisteredTask[];
    // (undocumented)
    getByName(taskName: string): RegisteredTask;
    // (undocumented)
    getSimilarTasks(taskName: string): string[];
    // (undocumented)
    has(name: string): boolean;
    // (undocumented)
    onTaskFailed(name: string): void;
    // (undocumented)
    onTaskFinish(name: string): void;
    // (undocumented)
    onTaskQueued(name: string): void;
    // (undocumented)
    onTaskStart(name: string): void;
    // (undocumented)
    register(name: string, task: RegisteredTask): void;
}

// @public (undocumented)
export const taskRegistry: TaskRegistry;

// @public (undocumented)
export const tasks: {
    register: typeof registerTask;
};

// @public (undocumented)
export enum TaskStatus {
    // (undocumented)
    Failed = "failed",
    // (undocumented)
    Finished = "finished",
    // (undocumented)
    Queued = "queued",
    // (undocumented)
    Registered = "registered",
    // (undocumented)
    Running = "running"
}

// Warnings were encountered during analysis:
//
// lib/index.d.ts:150:5 - (ae-forgotten-export) The symbol "registerTask" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
