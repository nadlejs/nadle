## API Report File for "nadle"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { InputLogObject } from 'consola';
import { RimrafAsyncOptions } from 'rimraf';

// @public
export type AliasOption = Record<string, string> | ((workspacePath: string) => string | undefined);

// @public
export type Awaitable<T> = T | PromiseLike<T>;

// @public
export type Callback<T = unknown, P = void> = (params: P) => T;

// @public
export interface ConfigBuilder {
    config(builder: Callback<TaskConfiguration> | TaskConfiguration): void;
}

// @public
export function configure(options: NadleFileOptions): void;

// @public
export const CopyTask: Task<CopyTaskOptions>;

// @public
export interface CopyTaskOptions {
    readonly exclude?: MaybeArray<string>;
    readonly from: string;
    readonly include?: MaybeArray<string>;
    readonly to: string;
}

// @public
export type Declaration = FileDeclaration | DirDeclaration;

// @public
export function defineTask<Options>(params: DefineTaskParams<Options>): Task<Options>;

// @public
export interface DefineTaskParams<Options> extends Task<Options> {
}

// @public
export const DeleteTask: Task<DeleteTaskOptions>;

// @public
export interface DeleteTaskOptions extends RimrafAsyncOptions {
    readonly paths: string | string[];
}

// @public
export interface DirDeclaration {
    readonly patterns: string[];
    readonly type: "dir";
}

// @public
export const ExecTask: Task<ExecTaskOptions>;

// @public
export interface ExecTaskOptions {
    readonly args: string[] | string;
    readonly command: string;
}

// @public
export interface FileDeclaration {
    readonly patterns: string[];
    readonly type: "file";
}

// @public
export interface ILogger {
    debug(message: InputLogObject | string, ...args: unknown[]): void;
    error(message: InputLogObject | string, ...args: unknown[]): void;
    info(message: InputLogObject | string, ...args: unknown[]): void;
    log(message: InputLogObject | string, ...args: unknown[]): void;
    warn(message: InputLogObject | string, ...args: unknown[]): void;
}

// @public
export namespace Inputs {
    export function dirs(...patterns: string[]): DirDeclaration;
    export function files(...patterns: string[]): FileDeclaration;
}

// @public
export type MaybeArray<T> = T | T[];

// @public
export namespace MaybeArray {
    export function toArray<T>(value: MaybeArray<T>): T[];
}

// @public
export interface NadleBaseOptions {
    readonly cache?: boolean;
    readonly cacheDir?: string;
    readonly footer?: boolean;
    readonly logLevel?: SupportLogLevel;
    readonly maxWorkers?: number | string;
    readonly minWorkers?: number | string;
    readonly parallel?: boolean;
}

// @public
export interface NadleFileOptions extends Partial<NadleBaseOptions> {
    readonly alias?: AliasOption;
}

// @public
export namespace Outputs {
    const files: typeof Inputs.files;
    const dirs: typeof Inputs.dirs;
}

// @public
export const PnpmTask: Task<PnpmTaskOptions>;

// @public
export interface PnpmTaskOptions {
    readonly args: string[];
}

// @public
export type Resolver<T = unknown> = T | Callback<T>;

// @public
export interface RunnerContext {
    readonly logger: ILogger;
    readonly workingDir: string;
}

// @public
export type SupportLogLevel = (typeof SupportLogLevels)[number];

// @public
export const SupportLogLevels: ["error", "log", "info", "debug"];

// @public
export interface Task<Options = unknown> {
    run: Callback<Awaitable<void>, {
        options: Options;
        context: RunnerContext;
    }>;
}

// @public
export interface TaskConfiguration {
    dependsOn?: string[];
    description?: string;
    env?: TaskEnv;
    group?: string;
    inputs?: Declaration[];
    outputs?: Declaration[];
    workingDir?: string;
}

// @public
export type TaskEnv = Record<string, string | number | boolean>;

// @public
export type TaskFn = Callback<Awaitable<void>, {
    context: RunnerContext;
}>;

// @public
export interface Tasks {
    register(name: string): ConfigBuilder;
    register(name: string, fnTask: TaskFn): ConfigBuilder;
    register<Options>(name: string, optTask: Task<Options>, optionsResolver: Resolver<Options>): ConfigBuilder;
}

// @public
export const tasks: Tasks;

// (No @packageDocumentation comment for this package)

```
